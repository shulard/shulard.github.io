<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>The missing validation middleware - PHP Conference Berlin 2022 - St√©phane HULARD / CHStudio</title>

        <meta name="description" content="In most web applications today, we need to validate the data submitted. There are multiple input validation methods. In France, we use the symfony/validator package a lot. However, those packages don‚Äôt validate the data at the right time.">
        <meta name="author" content="St√©phane HULARD">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="../assets/reveal.js/css/reveal.css">
        <link rel="stylesheet" href="../assets/css/font-awesome.min.css">
        <link rel="stylesheet" href="../assets/css/theme.css" id="theme">

        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="../assets/css/tomorrow.css">

        <style type="text/css">
            .reveal .social-me {
                float: right;
            }
            .reveal .social-me img {
                margin-bottom: 0px;
            }
            .reveal .social-me a {
                color: #FFF;
                margin-right: 10px;
            }
            .reveal .social-me a:hover {
                color: rgba(4, 32, 41, 0.9);
            }
            .reveal .social-me a:last-child {
                margin-right: 0;
            }
            .right {
                text-align: right;
            }
            .bottom {
                margin-top: 35% !important;
            }
            .top {
                margin-bottom: 35% !important;
            }
            .left {
                text-align: left;
            }
            .center {
                text-align: center;
            }
            .float-right {
                float: right;
            }
            .background {
                background-color: rgba(255, 255, 255, 0.9) !important;
            }
            .no-background {
                background: none !important;
            }
            .border-radius {
                border-radius: 20px;
            }
            code.fragment {
                padding: 12px;
            }
            .reveal code a {
                color: rgb(65, 65, 65);
            }
            .full-height {
                max-height: unset !important;
            }
            .reveal {
                background-color: rgba(0, 174, 239, 0.8);
            }
            .reveal h1.highlight *, .reveal p.highlight>* {
                background-color: rgba(4, 32, 41, 0.9);
                display: inline;
                padding-left: 15px;
                padding-right: 15px;
            }
            .reveal h1.highlight *:last-child {
                line-height: 2em
            }
            .reveal section>p {
                font-size: 1.2em;
            }
            .reveal section>a>img.plain {
                margin: 23px 0;
                height: 94px;
            }
            .reveal section>a+a>img.plain {
                margin-right: 10px;
            }
            .reveal section.invert {
                color: rgba(0, 0, 0, 0.8);
            }
            .reveal pre {
                font-size: 2rem;
            }
            .reveal pre code {
                padding: 1rem 1.5rem;
            }

            .reveal section.invert p.highlight>* {
                background-color: rgba(255, 255, 255, 0.9)
            }
            .reveal h1.highlight.white * {
                background-color: rgba(255, 255, 255, 0.9);
                color: rgba(0, 0, 0, 0.8);
            }
            .speaker-controls-notes .value {
                font-size: 1em !important;
            }

            .reveal .slide-background.present {
                opacity: 0.9;
            }

            .light-background .reveal .slide-background.present {
                opacity: 0.6;
            }

            .relative {
                position: relative;
            }
            .absolute {
                position: absolute !important;
                top: 0;
                left: 0;
            }
            .top120 {
                top: 120px;
            }

            @media print {
                .fragment.absolute {
                    display: none;
                }
            }
        </style>

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? '../assets/reveal.js/css/print/pdf.css' : '../assets/reveal.js/css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="../assets/reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal concave center">
            <div class="slides">
                <section data-background-image="img/missing-piece.jpg">
                    <h1 class="highlight white bottom" style="font-size: 2em;"><span>The missing validation middleware</span></h1>
                    <p class="global-footer">
                        <a href="https://chstudio.fr"><img src="../../logo.png" width="20" class="plain" /></a>
                        <a href="https://phpconference.com"><img src="../assets/images/ipc-logo.png" height="20" class="plain" /></a>
                        <span>St√©phane Hulard&nbsp;-&nbsp;PHP Conference Berlin&nbsp;<time datetime="2022-05-31">2022</time></span>
                    </p>
                    <aside class="notes">
                        Welcome to my presentation, I'm glad to be there in person.
                        <br/>
                        I'll start with a quick introduction of myself.
                        <br/>
                        Then, we are going to talk about middlewares, what they are and how they can be useful in your code.
                        <br/>
                        We'll continue with data validation. To keep my talk consistent I'll take a small example which will be used in every step.
                        <br/>
                        I'll try to explain how validation can be done inside your code in different ways and I'll show some limitations that I found in those solutions.
                        <br/>
                        We'll finally discover Valinor, a PHP library that can help you ensure data validation and object consistency inside your code. We'll talk about immutability and object internal state. I'll try to show you how it can help writing cleaner code in your projects.
                        <br/>
                        I know all these subjects are very technical, if you have questions we'll have some time at the end of the talk. I'll be there so don't be shy and reach me after if you want to discuss.
                        <br/>
                        I also prepared a small repository on GitHub, I'll share you the code at the end. All the examples I'll share with you will be there. Also the slides are already online, I'll share the link on Twitter just after.
                        <!--
                        Une intro digne de ce nom pour expliquer ce qu'on va voir

                        Pr√©senter notre exemple √† valider pour le fil conducteur:
                        Un point d'API pour mettre un jour un auteur et bien r√©appuyer
                        le pourquoi on fait chaque √©tape.

                        Revoir la partie What And Why
                        Mettre des slides intercalaires entre les parties code pour rappeler les points importants

                        Corriger les soucis sur le code
                        Remettre les exceptions dans le constructeur Author

                        Une conclusion ou je d√©cris dans quel contexte c'est pertinent
                        -->
                    </aside>
                </section>
                <section class="invert">
                    <p class="social-me">
                        <img src="img/moi.jpg" class="plain" width="250"/>
                        <br/>
                        <a class="white" target="_blank" href="https://twitter.com/s_hulard">@s_hulard</a>
                        <br/>
                        <a class="white" target="_blank" href="https://chstudio.fr"><i class="fa fa-globe"></i></a>
                        <a class="white" target="_blank" href="https://www.linkedin.com/in/shulard"><i class="fa fa-linkedin"></i></a>
                        <a class="white" target="_blank" href="https://github.com/shulard"><i class="fa fa-github"></i></a>
                        <a class="white" target="_blank" href="https://gitlab.com/shulard"><i class="fa fa-gitlab"></i></a>
                    </p>
                    <h1 class="highlight left"><span>St√©phane Hulard</span></h1>
                    <p class="left highlight">
                        <span class="fragment">CTO <sup>(CH Studio)</sup>, </span>
                        <span class="fragment">Trainer, </span>
                        <span class="fragment">Contributor.</span>
                    </p>
                    <aside class="notes">
                        So I'm Stephane Hulard.
                        <br/>
                        ‚ñ∂ I lead a small French company named CH Studio. We are specialized in PHP software development and help our customers build state of the art web application. I also love working on legacy projects to help the teams take them back.
                        <br/>
                        Today we are working on a medical image aggregation and search tool. We are not developing website, and are focused on specific web application.
                        <br/>
                        This explain the main reason we asked us how to improve our input handling and validation methods.
                        <br/><br/>
                        ‚ñ∂ I'm also a trainer, mainly around the software quality tools and methods.
                        <br/>
                        ‚ñ∂ Finally, I'm a contributor. I try to work on Open Source, read a lot of community content and attend conferences. Those different actions help me having a real life vision regarding my work and my daily routine.
                    </aside>
                </section>
<!--#########################################################################-->
                <section>
                    <section class="invert" data-background-image="img/magnifying-glass.jpg">
                        <h1 class="highlight white"><span>Middleware ?</span></h1>
                        <aside class="notes">
                            First, some concept. This talk title is about validation and middleware.
                            <br/>
                            Middleware is a development pattern which allows encapsulating different layer of logic between the inside and the outside of the application.
                        </aside>
                    </section>
                    <section class="invert">
                        <h1 class="highlight"><span>Like an onion üßÖ</span></h1>
                        <p><img class="plain background border-radius" src="img/middlewares.png" width="75%"></p>
                        <aside class="notes">
                            If you try to represent your application like an onion, you get something like this.
                            <br/>
                            In a web context, everything starts with a <code>Request</code>. This <code>Request</code> is composed of different parts that can be analyzed by your code to return a <code>Response</code>.
                            <br/>
                            If you take a step back for every program even outside the web, you can have the same logic. There is always an input, our program, then an output.
                            <br/>
                            I shown here four layers, we'll go deeper in the input validation after. We can have a lot of different layers.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Different layers‚Ä¶</span></h1>
                        <p class="highlight">
                            <span class="fragment"><strong>IN:</strong>&nbsp;Request, Preparation, Consolidation</span>
                        </p>
                        <p class="highlight">
                            <span class="fragment"><strong>CORE:</strong>&nbsp;Execution</span>
                        </p>
                        <p class="highlight">
                            <span class="fragment"><strong>OUT:</strong>&nbsp;Filtering, Adaptation, Response</span>
                        </p>
                        <aside class="notes">
                            For me, a program logic can be splitted in three parts.
                            <br/>
                            ‚ñ∂ The first one is for the input. We got a raw input, we can manipulate and validate it until it reaches the application code at the heart of our onion. In this part, we are also booting the application, loading the PHP code and everything that is mandatory to handle the request.
                            <br/>
                            ‚ñ∂ After that we arrive in the internal application code, also known as the <code>Controller</code>. Its job is to make something interesting with the request. This is where your specific logic is executed so it's important to limit the boilerplate code.
                            <br/>
                            ‚ñ∂ Finally, we can add some logic around the  Controller's response, this is where we build the output. For example we can enforce some HTTP headers, convert to a specific format‚Ä¶ This is also in this part that the Framework kernel lifecycle will be ended.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>‚Ä¶to reuse logic easily !</span></h1>
                        <p class="highlight">
                            <span>PSR-15, or specific implementations‚Ä¶</span>
                        </p>
                        <aside class="notes">
                            There are different official implementations depending the project and the framework.
                            <br/>
                            I think that the most important one is the PSR-15. If you're not familiar with PSRs, it's an acronym that means PHP Standard Recommandation. It's a user group which represents most of the important open source projects in our ecosystem. They try to find common solutions to different patterns in PHP, the PSR-15 is one of them related to Middlewares and Server Request handlers.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>How ?</span></h1>
                        <pre style="font-size: 1.2rem" class="absolute top120">
                            <code class="php" data-line-numbers>namespace App\Infrastructure\Http\Middlewares;

class Authenticate implements MiddlewareInterface
{
    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler
    ): ResponseInterface {
        try {
            $payload = $request->getContent();
            /** Execute here validation logic and extract object */
        } catch (ValidationError $error) {
            return Response::fromValidationError(422, $error);
        }

        return $handler->handle($request);
    }
}</code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers="3">namespace App\Infrastructure\Http\Middlewares;

class Authenticate implements MiddlewareInterface
{
    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler
    ): ResponseInterface {
        try {
            $payload = $request->getContent();
            /** Execute here validation logic and extract object */
        } catch (ValidationError $error) {
            return Response::fromValidationError(422, $error);
        }

        return $handler->handle($request);
    }
}</code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers="5-8,16">namespace App\Infrastructure\Http\Middlewares;

class Authenticate implements MiddlewareInterface
{
    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler
    ): ResponseInterface {
        try {
            $payload = $request->getContent();
            /** Execute here validation logic and extract object */
        } catch (ValidationError $error) {
            return Response::fromValidationError(422, $error);
        }

        return $handler->handle($request);
    }
}</code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers="9-14">namespace App\Infrastructure\Http\Middlewares;

class Authenticate implements MiddlewareInterface
{
    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler
    ): ResponseInterface {
        try {
            $payload = $request->getContent();
            /** Execute here validation logic and extract object */
        } catch (ValidationError $error) {
            return Response::fromValidationError(422, $error);
        }

        return $handler->handle($request);
    }
}</code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers="9-16">namespace App\Infrastructure\Http\Middlewares;

class Authenticate implements MiddlewareInterface
{
    public function process(
        ServerRequestInterface $request,
        RequestHandlerInterface $handler
    ): ResponseInterface {
        try {
            $payload = $request->getContent();
            /** Execute here validation logic and extract object */
        } catch (ValidationError $error) {
            return Response::fromValidationError(422, $error);
        }

        return $handler->handle($request);
    }
}</code>
                        </pre>
                        <aside class="notes">
                            The PSR-15 use the Chain of Responsibility pattern. It's designed in a way that we can combine every object in a specific order to obtain a result.
                            <br/>
                            Here is a sample code about a validation middleware. I've simplified it a bit to allow the code to fit in a slide but the important part are there.
                            <br/>
                            ‚ñ∂ You can see that our class extends MiddlewareInterface.
                            <br/>
                            ‚ñ∂ It enforces us to implement the process method which takes the Request and the next handler to be applied.
                            <br/>
                            ‚ñ∂ Our goal here is to generate a response, if the validation part fails, I can stop the process here and return a 422 response.
                            <br/>
                            ‚ñ∂ If you are not familiar with Middlewares it might not be easy to understand. However if we look at the onion picture we can see that we have the input part. Here we are validating the request content. Then we give the request to the next layer. If I want to work on the output, I can retrieve the response from the next layer in a variable and execute some logic on it.
                            <br/>
                            The Chain of Responsibility pattern allow us to build the different layers of our onion.
                            <br/>
                            I show you this code because I find it easier to understand but in your framework of choice it can be different and use Events for example.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Advantages ?</span></h1>
                        <p class="highlight"><span>Validate everything before reaching application code ‚Ä¶</span></p>
                        <p class="highlight"><span class="fragment">‚Ä¶ Combine and reuse objects easily ‚Ä¶</span></p>
                        <p class="highlight"><span class="fragment">‚Ä¶ Centralize logic for easier maintenance.</span></p>
                        <aside class="notes">
                            Using this chain is interesting because it allows stopping the process directly when we know the Response that can be returned.
                            <br/>
                            We execute only the relevant code and we can split all the different parts in specific objets that can be combined together.
                            <br/>
                            ‚ñ∂ You want authentication, cache, or ensure the response is a JSON, just add the Middleware layer‚Ä¶
                            <br/>
                            ‚ñ∂ Every layer can also be updated or replaced without breaking the whole chain.
                        </aside>
                    </section>
                </section>
                <section>
                    <section class="" data-background-image="img/magnifying-glass.jpg">
                        <h1 class="highlight white"><span class="white">Validation ?</span><span><sub>Why and How ?</sub></span></h1>
                        <aside class="notes">
                            Now that we are familiar with the concept of Middleware, we can come back to the validation. In most of the web application I worked with, I found that the input validation is bloated inside the controller.
                            <br/>
                            This forces to duplicate validation code when we manipulate the same data in multiple places.
                            <br/>
                            If you work on a small project it might not be a problem but when the codebase will grow, having every piece of logic contained in an object and reused when we need it help a lot. Easier to understand, easier to evolve, you'll thank your future you to have though this way.
                            <br/>
                            The input validation process for me is a part of those contained object. We wait for something, most of the time a highly structured input, then we manipulate it and we come back with a result. If I can express every possible input in an object, I can delegate all the validation logic to ensure that when I read my Controller, everything is ready to use.
                            <br/>
                            No more isset, no more array_key_exists or other structure controls. You create an object with a valid signature, expose some methods and you'll use them safely. It's safe because if an error is found, you'll never reach the Controller thanks to the Middleware.

                        <!--
                            Mais du coup qu'est-ce que √ßa veut dire, valider‚Ä¶

                            Remontons un peu le temps, voici un exemple de signature document√©e.
                            On peut voir qu'on prend en param√®tre un nombre, un objet et qu'on renvoit une cha√Æne de caract√®re.

                                Exemple de signature DocBlock

                            On a donc un premier niveau de validation, l'humain. Le code est explicite et d√©crit ce qu'il attend et ce qu'il retourne.

                            Sauf qu'on peut tr√®s bien faire n'importe quoi !

                                Exemple de non respect de la signature DocBlock

                            On a donc eu besoin de mieux v√©rifier que tout est en ordre, s'assurer que le programme va fonctionner. On introduit alors la validation des input / outputs.

                            Avant la validation √©tait faite en d√©but et fin de fonction

                                Exemple

                            Maintenant le moteur de PHP le fait en partie pour nous

                                Exemple type hinting

                            Ok donc tout est bon alors on arrive bien √† valider les donn√©es pour s'assurer du comportement ?

                            Oui mais on veut pouvoir g√©rer les diff√©rentes erreurs qui peuvent arriver‚Ä¶
                            Il y a aussi des r√®gles de validation plus sp√©cifiques, on ne va pas juste regarder le format d'une donn√©es mais aussi v√©rifier sa coh√©rence (date dans une p√©riode, nombre positif ou dans un range‚Ä¶)
                            Ok oui on veut pouvoir tout contr√¥ler quand on code mais du code est fait pour rendre un certain service, il faut pouvoir s'assurer qu'il le fera correctement.

                            Donc on a introduit des outils pour g√©rer la validation et capturer les erreurs. √áa permet de les g√©rer, encodage, suppression des espaces, fallback‚Ä¶

                            Ces outils s'appuient sur des objets et des r√®gles de validation. Souvent on initialise √† partir de donn√©es, on fait ensuite passer un "Validator" et on r√©cup√®re une liste de violations s'il y en a.

                                Exemple symfony/validator

                            Lacunes de cette approche, on peut avoir un objet invalide dans l'application si on oublie d'appliquer les r√®gles

                            On peut valider les donn√©es avant de construire l'objet aussi, mais √ßa force √† utiliser deux √©tapes distinctes, une pour valider l'autre pour initialiser.

                                Exemple Laravel

                            Avec la puissance des outils aujourd'hui on peut aller encore plus loin.
                            En effet avec les derni√®res version de PHP, √ßa commence √† dater maintenant, on a introduit le typage statique. On avance de plus en plus vers un typage fort mais optionnel dans le langage. Certains puristes des langages fortement typ√©s pourront ne pas √™tre compl√®tement d'accord, n'emp√™che que √ßa avance dans le bon sens.

                            Nos objets sont maintenant extr√®mement explicites. Nos propri√©t√©s sont typ√©es, l'arbre d'objet est tr√®s pr√©cis.

                                Exemple d'objet avec propri√©t√©s + sous ensemble d'objets.

                            L√† ou pr√©c√©demment on doit d√©clarer nous m√™mes les r√®gles de validation, finalement une partie du travail pourrait d√©j√† √™tre extrait automatiquement par le langage.
                            Bien sur certaines r√®gles m√©tiers comme, la date ne doit pas √™tre le 8√®me jour du mois ne peuvent pas √™tre d√©clar√©es juste avec le typage statique mais on se rapproche de quelque chose d'automatique.

                            Et je ne sais pas pour vous mais moi quand la machine fait le travail √† ma place √ßa me fait plaisir. J'ai aussi un peu plus confiance dans la machine pour respecter les r√®gles qu'en moi.

                            Au final on peut faire en sorte que toutes les donn√©es qui rentrent dans l'application soient mapp√©es sur des objets et donc lorsqu'elles atteignent le coeur de l'application pour √™tre utilis√©es, on sait d√©j√† exactement qu'elles sont bien propres et utilisables. La signature des objets permet de manipuler tout √ßa tout en maintenant le contr√¥le.

                            Disclaimer, l'id√©e ici n'est pas de dire que certains outils sont mauvais et d'autres r√©volutionnaires. C'est plut√¥t de pr√©senter une fa√ßon de faire qui me parait plus pertinente et plus efficace. Si avec moins de code je peux avoir un r√©sultat √©quivalent ou meilleur pourquoi m'en priver !
                        -->
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span class="white">Start with a problem‚Ä¶</span></h1>
                        <p class="highlight"><span>A <code>Contract</code> management project:</span></p>
                        <p class="highlight">
                            <span>‚ñ∂ As a <code>User</code> I want to create a <code>Contract</code>.</span><br/>
                            <span>‚ñ∂ A <code>Contract</code> is composed of dates and an <code>Author</code>.</span><br/>
                            <span>‚ñ∂ An <code>Author</code> is identified by its <code>Email</code> address.</span>
                        </p>
                        <pre style="font-size: 1.2rem" class="fragment">
                            <code class="json" data-line-numbers>POST /contracts

{
    "starts_at": "2022-01-01 00:00:00",
    "expires_at": "2022-12-31 00:00:00",
    "author": {
        "name": "Neslon Mandela",
        "email": "nelson.mandela@mail.com"
    }
}
                            </code>
                        </pre>
                        <aside class="notes">
                            As software developers our goal is to solve problems. For this we write code but we need to understand clearly the problem to find a correct solution.
                            <br/>
                            Here I express a small user story from a contract management project. I want to be able to create a contract so I wrote the expectations. We can see 3 main concepts that can be extracted: Contract, Author, Email.
                            <br/>
                            ‚ñ∂ We can materialize this requirement by adding a new API endpoint in our project which will take the given JSON payload as input.
                            <br/>
                            We now have an input and you can see that it's well defined. We can represent those fields inside some objects that will ensure a consistent state. If we are able to build the object, the data is valid, if not, we might send some errors back to the user.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span class="white">Define objects: Contract</span></h1>
                        <pre style="font-size: 1.2rem">
                            <code class="php" data-line-numbers>class Contract
{
    public function __construct(
        private DateTimeInterface $startsAt,
        private DateTimeInterface $expiresAt,
        private Author $author
    ) {
        if ($expiresAt < $startsAt) {
            throw new InvalidArgumentException(
                '"expiresAt" date must be after "startsAt".'
            );
        }
    }
}
                            </code>
                        </pre>
                        <p class="highlight"><span>‚úÖÔ∏è: <code>"expiresAt"</code> must be after <code>"startsAt"</code></span></p>
                        <aside class="notes">
                            If you're not familiar with this syntax, it use PHP 8.1 promoted properties. I define a Contract object to represent the relevant data and the rules. I don't want the startsAt date to be after the expiration date. When defining an object I must ensure all the rules are applied.
                            <br/>
                            This is important because I never know in advance where my object will be used. It must be strict and exhaustive, I chose to represent a piece of information, I want consistency in it.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span class="white">Define objects: Author</span></h1>
                        <pre style="font-size: 1.2rem">
                            <code class="php" data-line-numbers>class Author
{
    public function __construct(
        private string $name,
        private Email $email
    ) {
        if (empty($name)) {
            throw new InvalidArgumentException(
                "Author name can't be empty."
            );
        }
    }
}
                            </code>
                        </pre>
                        <p class="highlight"><span>‚úÖÔ∏è: <code>"name"</code> must not be empty.</span></p>
                        <aside class="notes">
                            Same here with a Author object. You can see a different rule, I want to be sure that my author name is not empty.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span class="white">Define objects: Email</span></h1>
                        <pre style="font-size: 1.2rem">
                            <code class="php" data-line-numbers>class Email
{
    public function __construct(
        private string $email
    ) {
        if (false === filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new \InvalidArgumentException(
                "Email $email is not valid."
            );
        }
    }
}
                            </code>
                        </pre>
                        <p class="highlight"><span>‚úÖÔ∏è: <code>"email"</code> must be compliant to RFC.</span></p>
                        <aside class="notes">
                            Finally, the Email object. It's important to make a clear difference between an Email and a simple string in your code. Whenever you can trust your methods inputs, you'll have simpler code to read and use.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span class="white">Object hierarchy</span></h1>
                        <pre style="font-size: 1.2rem" class="absolute top120">
                            <code class="json" data-line-numbers>{
    "starts_at": "2022-01-01 00:00:00",
    "expires_at": "2022-12-31 00:00:00",
    "author": {
        "name": "Neslon Mandela",
        "email": "nelson.mandela@mail.com"
    }
}
                            </code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="json" data-line-numbers="2,3,4">{
    "starts_at": "2022-01-01 00:00:00",
    "expires_at": "2022-12-31 00:00:00",
    "author": {
        "name": "Neslon Mandela",
        "email": "nelson.mandela@mail.com"
    }
}
                            </code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="json" data-line-numbers="5,6">{
    "starts_at": "2022-01-01 00:00:00",
    "expires_at": "2022-12-31 00:00:00",
    "author": {
        "name": "Neslon Mandela",
        "email": "nelson.mandela@mail.com"
    }
}
                            </code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="json" data-line-numbers="6">{
    "starts_at": "2022-01-01 00:00:00",
    "expires_at": "2022-12-31 00:00:00",
    "author": {
        "name": "Neslon Mandela",
        "email": "nelson.mandela@mail.com"
    }
}
                            </code>
                        </pre>
                        <p class="highlight bottom"><span>3 objects to express our input: "Contract", "Author", "Email"</span></p>
                        <aside class="notes">
                            When we work on our code, it's important to describe the expectations.
                            Handling an input requires expectations, we need to be sure that we have everything in it before executing the inner logic in our software.
                            <br/>
                            In the JSON payload I shared with you at the beginning of this section, we can retrieve the 3 objects hierarchy.
                            <br/>
                            ‚ñ∂ Contract, ‚ñ∂ Author, ‚ñ∂ Email.
                            <br/>
                            We have answered the Why. This is exactly why validation is important in our projects. Now let's see how we can validate our input and build our objects.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Back to basics</span></h1>
                        <pre style="font-size: 1.2rem" class="absolute top120">
                            <code class="php" data-line-numbers>/**
 * @param DateTimeInterface $startsAt
 * @param DateTimeInterface $expiresAt
 * @param string $authorName
 * @param string $authorEmail
 */
function createContract(
    $startsAt,
    $expiresAt,
    $authorName,
    $authorEmail
) {
    /** code logic */
}
                            </code>
                        </pre>
                        <aside class="notes">
                            If we look at our software like they are functions. We can wrote a function signature. It has a name, some parameters and return a value or nothing.
                            <br/>
                            Those parameters can have a specific type and the return value another.
                            <br/>
                            Here I just added a docblock comment to describe expectations.
                            <br/>
                            We can see that this comment tell us the parameters type, we have a first validation layer, the Human. The code is explicit enough we know what is required and what is expected.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Break it easily‚Ä¶</span></h1>
                        <pre style="font-size: 1.2rem" class="absolute top120">
                            <code class="php" data-line-numbers>createContract(
    'a',
    'a',
    -18,
    0
);

// Error in the function body because parameters have the wrong type.
                            </code>
                        </pre>
                        <aside class="notes">
                            The problem here is that nothing prevent us to call the function with some wrong parameters values.
                            <br/>
                            Today, we can leverage the language to help us avoiding some mistakes, this is called static type hinting !
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>With static type hinting !</span></h1>
                        <pre style="font-size: 1.2rem" class="absolute top120">
                            <code class="php" data-line-numbers>function createContract(
    DateTimeInterface $startsAt,
    DateTimeInterface $expiresAt,
    string $authorName,
    string $authorEmail
) {
    /** code logic */
}
                            </code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers>createContract(
    'a',
    'a',
    -18,
    0
);

// Type error: Argument 1 passed to createContract() must be DateTimeInterface, string given,
// called in xxx.php on line xx
                            </code>
                        </pre>
                        <aside class="notes">
                            Now, PHP will help us validating the data. You can see that the function signature was updated. I applied the typing on a function here because it's simple for my slides but you can apply this to you class methods and propreties.
                            <br/>
                            ‚ñ∂ If you try to give a string instead of a DateTimeInterface instance, you'll get a <code>TypeError</code>.
                            <br/>
                            Now we have a code that validates itself that's pretty nice.
                            <br/>
                            But that's not what we want, we don't want to have unhandled PHP TypeError thrown from everywhere. We need to capture the errors. Also here we are just validating that the parameter types are correct.
                            <br/>
                            Most of the time we want to move further with more specific validation rules to ensure consistency. Here I want to be sure that the email string is correctly formed to be an email, I also want the expiresAt date to be after the startsAt.
                            <br/>
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Only basic PHP typing‚Ä¶</span></h1>
                        <p class="highlight"><span>Nice but don't cover all the cases.</span></p>
                        <aside class="notes">
                            We want a complete control when we code. Remind you that our code was written to answer a specific question based on an input. We need to ensure that it'll be able to do it correctly.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Use the objects !</span></h1>
                        <pre style="font-size: 1.2rem" class="absolute top120">
                            <code class="php" data-line-numbers>function createContract(
    Contract $contract
) {
    /**
     * $contract contains all properties
     * All values are valid and respect the rules.
     */
}
                            </code>
                        </pre>
                        <aside class="notes">
                            If I use a specific object to represent my input, the function signature is simpler. It's also more expressive, you want to create a contract so I give you a Contract object to do it.
                            <br/>
                            But, to do this I need to create my Contract object before and ensure everything is fine. There are multiple solutions here that already exists and are well known. I'll take two examples, the Symfony Validator and the Laravel Validator.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Prepare input data</span></h1>
                        <pre style="font-size: 1.2rem">
                            <code class="php" data-line-numbers>use Symfony\Component\Validator\Constraints as Assert;

class Author
{
    /** @Assert\NotEmpty */
    private string $name;

    public function __construct(
        string $name,
        private Email $email
    ) {
        $this->name = $name;
    }
}
                            </code>
                        </pre>
                        <aside class="notes">
                            This is still a simple example. I need to update my object definition here if I want to be able to validate it. To use the Symfony validator I choose to write annotations here.
                            <br/>
                            These annotations are powerful because you can combine them and create very complex rules to validate your data.
                            <br/>
                            It's the way this validator works, you initialize a bunch of data then you validate and retrieve the errors based on the rules.
                            <br/>
                            Here I have only one rule, my name must not be empty. I don't need to validate the email because it must have been initialized correctly before, I can trust the Email object. I just show you the Author object as an example, if I want to use the Symfony Validator on my 3 defined objects, I need to change them the same way.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Prepare input data</span></h1>
                        <pre style="font-size: 1.2rem" class="absolute top120">
                            <code class="php" data-line-numbers>use Symfony\Component\Validator\Validator\ValidatorInterface;

$validator = /** Some code to retrieve the ValidatorInterface instance */
$email = new Email(‚Ä¶);

$author = new Author('', $email);

$errors = $validator->validate($author);
if (count($errors) > 0) {
    //Build error response
}

//Build valid response
                            </code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers="6">use Symfony\Component\Validator\Validator\ValidatorInterface;

$validator = /** Some code to retrieve the ValidatorInterface instance */
$email = new Email(‚Ä¶);

$author = new Author('', $email);

$errors = $validator->validate($author);
if (count($errors) > 0) {
    //Build error response
}

//Build valid response
                            </code>
                        </pre>
                        <aside class="notes">
                            Now we must use a Validator instance to validate our date. It will give us an error list if there are some violations. That's interesting because we don't want to break our code completely on each encontered error. If we can retrieve the whole list, we can explain to the user what's wrong.
                            <br/>
                            ‚ñ∂ My main concern with this approach is that our <code>Author</code> object is build before the validation.
                            <br/>
                            Therefore we are allowing an object like this to be built with an invalid internal state, in our case an empty name. For me that's a huge issue because if sometimes we forget to run the validator, we can't rely on our object anymore. We are getting back the a previous step.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Validates before‚Ä¶</span></h1>
                        <pre style="font-size: 1.2rem" class="absolute top120">
                            <code class="php" data-line-numbers>$validator = Validator::make($request->all(), [
    'name' => 'required|max:255'
]);

if ($validator->fails()) {
    /** Build error response */
}

$author = new Author($request->get('name'), $email);
                            </code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers="1-3">$validator = Validator::make($request->all(), [
    'name' => 'required|max:255'
]);

if ($validator->fails()) {
    /** Build error response */
}

$author = new Author($request->get('name'), $email);
                            </code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers="5-9">$validator = Validator::make($request->all(), [
    'name' => 'required|max:255'
]);

if ($validator->fails()) {
    /** Build error response */
}

$author = new Author($request->get('name'), $email);
                            </code>
                        </pre>
                        <aside class="notes">
                            For sure we can validate the data before initializing our object. This other example uses the Laravel validator.
                            <br/>
                            ‚ñ∂ It can take an array as input and a list of validation rules.
                            <br/>
                            ‚ñ∂ The same way than with our previous examples, we can verify if the validation failed or not and we can build our Author object with the validated data.
                            <br/>
                            That's interesting because here we don't need to update our Author object definition. The validation process completely external. However we need to define the rules in two places, first in the Author constructor, then in the Validator call.
                            <br/>
                            Also and it's the same with Symfony, you still need to create your object yourself. You can use a Serializer or create them manually, it's an extra step in your code.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Limitations ?</span></h1>
                        <p class="highlight"><span class="fragment">An input can be very complex‚Ä¶</span></p>
                        <p class="highlight"><span class="fragment">Modeling as object clearly define expectations‚Ä¶</span></p>
                        <p class="highlight"><span class="fragment">Validators doesn't work efficiently with those objects.</span></p>
                        <aside class="notes">
                            ‚ñ∂ A choice is always context dependent but if you try validating complex input with the previous solutions, you'll have a complex piece of code.
                            <br/>
                            ‚ñ∂ However all the details are already in my objects, the typing, the exception handling, the structure. As a developer I'm lazy and I love to delegate all the possible steps to the machine. Creating objects manually is not the funniest task to do.
                            <br/>
                            ‚ñ∂ We saw that current validators will not be very efficient in our case.
                        </aside>
                    </section>
                </section>
                <section>
                    <section class="invert left" data-background-image="img/idea.jpg">
                        <h1 class="highlight bottom"><span>üí° <code>cuyz/valinor</code></span></h1>
                        <p class="highlight"><span>Map any input into a strongly-typed value object structure.</span></p>
                        <aside class="notes">
                            Let's introduce Valinor, a library which allows to take an unstructured input and build a valid object structure from it.
                            <br/>
                            For me it's the best of both worlds, you can define your objects with specific rules then map them to an input. It combines the two approaches I show you before.
                            <br/>
                            Diclaimer, my goal is not to tell that some tools are good and others are bad and should not be used. I just show you another way to validate your data inside your application. I prefer working with objects and Valinor allows me to have validated objects.
                            <br/>
                            The object signatures allow to control everything and it's awesome ! Also if you use Middlewares, it'll help having a central place in your code for your input validation.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>How it works ?</span></h1>
                        <p class="highlight"><span class="fragment">Read functions and objects signatures,</span></p>
                        <p class="highlight"><span class="fragment">Build validation rules by itself,</span></p>
                        <p class="highlight"><span class="fragment">Validates the data before creating objects,</span></p>
                        <p class="highlight"><span class="fragment">Ensure that you get ready to use objects at the end.</span></p>
                        <aside class="notes">
                            Ok, another new library, why is it really different than others ?
                            <br/>
                            ‚ñ∂ First you don't need to write the validation rules that are already built into your code,
                            <br/>
                            ‚ñ∂ it will extract them by itself.
                            <br/>
                            ‚ñ∂ It will validate the data before creating the objects and will aggregate all the encountered issues. You're constructor broke, you get it, a static type is not matched, you get it‚Ä¶
                            <br/>
                            ‚ñ∂ Then if everything is fine, you'll get your ready to use object with all the data in it.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Show me the code !</span></h1>
                        <pre style="font-size: 1.2rem" class="absolute top120">
                            <code class="php" data-line-numbers>try {
    $contract = (new \CuyZ\Valinor\MapperBuilder())
        ->mapper()
        ->map(
            Contract::class,
            new \CuyZ\Valinor\Mapper\Source\JsonSource($json)
        );
} catch (\CuyZ\Valinor\Mapper\MappingError $error) {
    // Do something‚Ä¶
}
                            </code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers="1,8-10">try {
    $contract = (new \CuyZ\Valinor\MapperBuilder())
        ->mapper()
        ->map(
            Contract::class,
            new \CuyZ\Valinor\Mapper\Source\JsonSource($json)
        );
} catch (\CuyZ\Valinor\Mapper\MappingError $error) {
    // Do something‚Ä¶
}
                            </code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers="2-4,7">try {
    $contract = (new \CuyZ\Valinor\MapperBuilder())
        ->mapper()
        ->map(
            Contract::class,
            new \CuyZ\Valinor\Mapper\Source\JsonSource($json)
        );
} catch (\CuyZ\Valinor\Mapper\MappingError $error) {
    // Do something‚Ä¶
}
                            </code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers="5,6">try {
    $contract = (new \CuyZ\Valinor\MapperBuilder())
        ->mapper()
        ->map(
            Contract::class,
            new \CuyZ\Valinor\Mapper\Source\JsonSource($json)
        );
} catch (\CuyZ\Valinor\Mapper\MappingError $error) {
    // Do something‚Ä¶
}
                            </code>
                        </pre>
                        <aside class="notes">
                            ‚ñ∂ The code is a bit more complex here because we use a try / catch to retrieve validation errors.
                            <br/>
                            ‚ñ∂ Also the MapperBuilder allows to retrieve the correct object to build your data from the input. It also allows configuring Valinor. There are a lot of documented possibilies.
                            <br/>
                            ‚ñ∂ Once your have written it, it's like some default code. The important part is the map method call which define input data and output object.
                            <br/>
                            With this we can retrieve a complete and valid <code>Contract</code> object. For sure with this example it's a huge solution for a small problem. You might chose a basic and simple tool if you have only one object with a small hierarchy.
                            <br/>
                            However, Valinor allows to map any input to an object and validates it. Think about all the possibilies inside your API payloads or parameters. Also it'll will shine inside a validation Middleware.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Validation errors ?</span></h1>
                        <pre style="font-size: 1.2rem" class="">
                            <code class="php" data-line-numbers>{
    "starts_at": "2022-01-01 00:00:00",
    "author": {
        "name": "",
        "email": "nelson.mandelamail.com"
    }
}</code>
                        </pre><pre style="font-size: 1.2rem" class="fragment">
                            <code class="json">{
    "expiresAt.value": "Cannot be empty and must be filled with a value matching type.",
    "author.email": "Email nelson.mandelamail.com is not valid.",
    "author": "Author name can't be empty."
}</code>
                        </pre>
                        <aside class="notes">
                            As I already said, Valinor is able to extract the list of all errors which applies on an input.
                            <br/>
                            Here I explicitely give a wrong input. Mandatory fields are not present, author name is empty‚Ä¶
                            <br/>
                            Valinor will throw an Exception. This error allows you to retrieve the message hierarchy and transform them to a JSON like I do here.
                            <br/>
                            There is a built-in translation mecanism so you can have a full control over the different returned messages.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Supports type annotations</span></h1>
                        <pre style="font-size: 1.2rem" class="absolute top120">
                            <code class="php" data-line-numbers>class Author
{
    /** @var non-empty-string */
    private string $name;

    public function __construct(
        string $name,
        private Email $email
    ) {
        $this->name = $name;
        if (empty($name)) {
            throw new InvalidArgumentException(
                "Author name can't be empty."
            );
        }
    }
}
                            </code>
                        </pre>
                        <pre style="font-size: 1.2rem" class="absolute top120 fragment fade-in">
                            <code class="php" data-line-numbers="3,4">class Author
{
    /** @var non-empty-string */
    private string $name;

    public function __construct(
        string $name,
        private Email $email
    ) {
        if (empty($name)) {
            throw new InvalidArgumentException(
                "Author name can't be empty."
            );
        }
        $this->name = $name;
    }
}
                            </code>
                        </pre>
                        <aside class="notes">
                            As we already seen, we can't only rely on PHP typing to define our objects. We need to add other details, a common way is to use annotations. As you can see here, I added the "non-empty-string" annotation to my author object. Since annotation are not real code, I keep my constructor as strict as possible.
                            <br/>
                            To prevent conflicts or duplication of the type annotations, this library tries to handle most of the type annotations that are accepted by PHPStan and Psalm.
                            <br/>
                            ‚ñ∂ If your code is already passed through one of those static analysis tool, nothing to do metadata will be used.
                            <br/>
                            If not, I encourage you to take a look at them, they allow to detect a lot of issues inside your code and you can fix them before it reaches the production server.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Ready to use Objects</span></h1>
                        <pre style="font-size: 1.2rem" class="absolute top120">
                            <code class="php" data-line-numbers>$contract->author()->email() // Email object</code>
                        </pre>
                        <aside class="notes">
                            Once all the validations have been passed, you get a complete and valid object. You just need to call the different methods.
                            You object can only expose the necessary details and ensure consistency.
                            <br/>
                            No more setters in this context because when your object are built, the data is already valid. You got Immutability at almost no cost.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>ü§ØÔ∏è ultime validation !</span></h1>
                        <p class="highlight"><span>A bit more complex‚Ä¶</span><span class="fragment">‚Ä¶huge possibilities</span></p>
                        <p class="highlight"><span class="fragment">Can be extended and adapted to your specific needs</span></p>
                        <p class="highlight"><span class="fragment">Try Valinor inside a Middleware !</span></p>
                        <aside class="notes">
                            For sure using Valinor is a bit more complex than Laravel or Symfony validator. But the expected result is not exactly the same. Valinor allows initializing the objects for you so it'll remove a lot of boilerplate code from your projects.
                            <br/>
                            ‚ñ∂ Inside a Middleware it can ensure that every input is correctly formed and you can automatically transform the errors to be sent back to the user before reaching your application controller.
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section data-background-image="img/thinking.jpg" data-background-color="rgba(255, 255, 255, 1)">
                        <h1 class="left bottom highlight"><span>What to do now ?</span></h1>
                        <aside class="notes">
                            Now we have explored a new tool and library. Maybe you're already familiar with the possibilities, maybe it's completely new.
                            <br/>
                            What to do now ? As always it's not a silver bullet, complexity has a cost.
                        </aside>
                    </section>
                    <section class="invert left">
                        <h1 class="highlight"><span>Give it a try !</span></h1>
                        <p class="highlight"><span>A GitHub project with an exhaustive README,</span></p>
                        <p class="highlight"><span>Under active development.</span></p>
                        <aside class="notes">
                            However it's an open project so you can already explore the code and give it a try. I'll share with you a really small repository to show you how it can be used.
                            <br/>
                            It doesn't handle all the cases but since it's under active development you can submit issues and try working with the authors to improve if you want. The more project will use it, the more powerful it will be !
                        </aside>
                    </section>
                    <section class="invert left">
                        <h1 class="highlight"><span>Think about validation</span></h1>
                        <p class="highlight"><span>Have you invalid object in your code ?</span></p>
                        <p class="highlight"><span class="fragment">Are your current tools the best for you ?</span></p>
                        <aside class="notes">
                            Maybe this presentation make you think that validating data is complex. You may just think about how you actually validate your inputs. By using a proper validation solution, you can limit the number of problems your code will encounter and that's a very good reason to try different tools !
                            <br/>
                            Also, if you're already familiar with other validation tools, don't throw them away, every software and library have its strengths and weaknesses. Just try to be informed on what the community is working on !
                        </aside>
                    </section>
                    <section class="invert left">
                        <h1 class="highlight"><span>Stay open minded üòâÔ∏è</span></h1>
                        <p class="highlight"><span>All the solutions exists for correct reasons,</span></p>
                        <p class="highlight"><span class="fragment">Stay informed of new tools and practices,</span></p>
                        <p class="highlight"><span class="fragment">Try new things, you might be surprised !</span></p>
                        <aside class="notes">
                            And I'll finish on this one, which is the most important for me. You always need to keep an eye on cutting edge tools and technologies. Try to read articles, wrote some tests around a new tool you discovered‚Ä¶ The more you'll see, the best your solutions will be.
                            <br/>
                            Don't forget that most of us are software developers and engineers, our job is to find solutions not to generate problems. Our role is to find the correct tools depending the context.
                        </aside>
                    </section>
                </section>
<!--#########################################################################-->
                <section class="invert" data-background-image="../assets/images/thank-you.jpg">
                    <img src="img/frame.png" class="plain" style="position:absolute; right:0; top:0;" width="250" />
                    <p class="highlight right bottom">
                        <span><i class="fa fa-twitter"></i> @s_hulard</span><br/><br/>
                        <small>https://github.com/CuyZ/Valinor</small><br/>
                        <small>https://github.com/shulard/ipc-valinor-sample</small>
                    </p>
                    <aside class="notes">
                        I added here two important links. The Valinor repository and my sample repository which I presented you in the slides.
                        <br/>
                        This QRCode will send you the my project, in the README, you'll also have the link to Valinor.
                        <br/>
                        Thank for your attention‚Ä¶ Feel free to ask any question !
                    </aside>
                </section>
            </div>
        </div>

        <script src="../assets/reveal.js/js/reveal.js"></script>
        <script src="../assets/javascripts/mermaid.min.js"></script>

        <script>
            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: false,
                progress: true,
                history: true,
                center: true,
                pdfSeparateFragments: false,
                showNotes: 'separated-page',

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: '../assets/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: '../assets/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../assets/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../assets/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: '../assets/reveal.js/plugin/zoom-js/zoom.js', async: true },
                    { src: '../assets/reveal.js/plugin/notes/notes.js', async: true }
                ]
            });

            mermaid.initialize({startOnLoad:true});
        </script>
    </body>
</html>
