<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Dive in the dependency injection container‚Ä¶ - St√©phane HULARD / CHStudio</title>

        <meta name="description" content="D√©couvrons ce pattern et comment il fonctionne √† travers des exemples r√©els. En prenant comme base le conteneur int√©gr√© √† Symfony, mais en essayant d‚Äôouvrir √† toutes les solutions offertes par la communaut√© (aka PSR11), j‚Äôesp√®re vous faire d√©couvrir des capacit√©s cach√©es dans votre application !

        Les conteneurs d‚Äôinjection de d√©pendance font parti int√©grante des frameworks que nous utilisons tous les jours. On peut m√™me dire que c‚Äôest le coeur de votre application. Aujourd'hui, on essaie d'automatiser au maximum leur configuration pour faciliter leur usage, mais comme ils permettent de cr√©er, configurer, combiner des objets, ils gagnent √† √™tre mieux connus et ma√Ætris√©s.">
        <meta name="author" content="St√©phane HULARD">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

        <link rel="stylesheet" href="../assets/reveal.js/css/reveal.css">
        <link rel="stylesheet" href="../assets/css/font-awesome.min.css">
        <link rel="stylesheet" href="../assets/css/theme.css" id="theme">

        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="../assets/css/tomorrow.css">

        <style type="text/css">
            .reveal .social-me {
                float: right;
            }
            .reveal .social-me img {
                margin-bottom: 0px;
            }
            .reveal .social-me a {
                color: #FFF;
                margin-right: 10px;
            }
            .reveal .social-me a:hover {
                color: rgba(4, 32, 41, 0.9);
            }
            .reveal .social-me a:last-child {
                margin-right: 0;
            }
            .right {
                text-align: right;
            }
            .bottom {
                margin-top: 35% !important;
            }
            .top {
                margin-bottom: 35% !important;
            }
            .left {
                text-align: left;
            }
            .float-right {
                float: right;
            }
            .background {
                background-color: rgba(255, 255, 255, 0.9) !important;
            }
            .no-background {
                background: none !important;
            }
            .border-radius {
                border-radius: 20px;
            }
            code.fragment {
                padding: 12px;
            }
            .full-height {
                max-height: unset !important;
            }
            .reveal {
                background-color: rgba(0, 174, 239, 0.8);
            }
            .reveal h1.highlight *, .reveal p.highlight>* {
                background-color: rgba(4, 32, 41, 0.9);
                display: inline;
                padding-left: 15px;
                padding-right: 15px;
            }
            .reveal h1.highlight *:last-child {
                line-height: 2em
            }
            .reveal section>p {
                font-size: 1.2em;
            }
            .reveal section>a>img.plain {
                margin: 23px 0;
                height: 94px;
            }
            .reveal section>a+a>img.plain {
                margin-right: 10px;
            }
            .reveal section.invert {
                color: rgba(0, 0, 0, 0.8);
            }
            .reveal pre {
                font-size: 2rem;
                line-height: 1.5;
            }
            .reveal pre code {
                padding: 1rem 1.5rem;
            }

            .reveal section.invert p.highlight>* {
                background-color: rgba(255, 255, 255, 0.9)
            }
            .speaker-controls-notes .value {
                font-size: 1em !important;
            }

            .reveal .slide-background.present {
                opacity: 0.9;
            }

            .light-background .reveal .slide-background.present {
                opacity: 0.6;
            }

            .relative {
                position: relative;
            }
            .absolute {
                position: absolute !important;
                top: 0;
                left: 0;
            }
            .top120 {
                top: 120px;
            }

            @media print {
                .fragment.absolute {
                    display: none;
                }
            }
        </style>

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? '../assets/reveal.js/css/print/pdf.css' : '../assets/reveal.js/css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="../assets/reveal.js/lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal concave center">
            <div class="slides">
                <section data-background-image="img/dive.jpg">
                    <h1 class="highlight" style="font-size: 1.5em;"><span>Dive in the dependency injection container</span></h1>
                    <p class="global-footer">
                        <a href="https://chstudio.fr"><img src="../../logo.png" width="20" class="plain" /></a>
                        <a href="https://afup.org"><img src="img/afup.png" width="20" class="plain" /></a>
                        <span><time datetime="2020-10-27">2020</time>&nbsp;-&nbsp;Dive in the dependency injection container</span>
                    </p>
                    <aside class="notes">
                        Bonjour !
                        <br/>
                        Nous allons parler de pattern et de conventions de d√©veloppement. La plupart de vos outils de tout les jours utilisent des Design Pattern ou patron de conception en fran√ßais. En tant que d√©veloppeur il est int√©ressant de les comprendre en profondeur.
                        <br/>
                        On va s'int√©resser principalement √† l'un d'entre eux, le conteneur d'injection de d√©pendance.
                        <br/>
                        Ce pattern permet de cr√©er une grosse usine √† fabriquer des objets que vous assemblez ensuite comme des briques l√©gos. Aujourd'hui les frameworks du march√©, Symfony, Laravel, et autres sont construit autour de ce conteneur.
                    </aside>
                </section>
                <section class="invert">
                    <p class="social-me">
                        <img src="img/moi.jpg" class="plain" width="250"/>
                        <br/>
                        <a class="white" target="_blank" href="https://twitter.com/s_hulard">@s_hulard</a>
                        <br/>
                        <a class="white" target="_blank" href="https://chstudio.fr"><i class="fa fa-globe"></i></a>
                        <a class="white" target="_blank" href="https://www.linkedin.com/in/shulard"><i class="fa fa-linkedin"></i></a>
                        <a class="white" target="_blank" href="https://github.com/shulard"><i class="fa fa-github"></i></a>
                        <a class="white" target="_blank" href="https://gitlab.com/shulard"><i class="fa fa-gitlab"></i></a>
                    </p>
                    <h1 class="highlight left"><span>St√©phane Hulard</span></h1>
                    <p class="left highlight">
                        <span class="fragment">Consultant, </span>
                        <span class="fragment">Formateur, </span>
                        <span class="fragment">Contributeur.</span>
                    </p>
                    <aside class="notes">
                        Je commence par me pr√©senter, je suis St√©phane Hulard, ‚ñ∂ consultant ind√©pendant. J'aime beaucoup travailler sur des projets legacy pour accompagner les √©quipes √† les reprendre en main.
                        <br/>
                        ‚ñ∂ Je suis aussi formateur principalement autour des outils et m√©thodes li√©s √† la qualit√© logicielle.
                        <br/>
                        ‚ñ∂ Et enfin contributeur, pas autant que je le voudrais mais les projets open sources me permettent d'√©largir ma vision du m√©tier en b√©n√©ficiant de l‚Äôexpertise et du soutien de la communaut√© ce qui est un atout pr√©cieux.
                    </aside>
                </section>
                <section class="stack">
                    <section data-background-image="img/layers.jpg" data-background-color="rgba(255, 255, 255, 1)">
                        <h1 class="highlight"><span>Un pattern ?</span></h1>
                        <aside class="notes">
                            Pourquoi avoir eu l'id√©e d'ajouter cette usine d'objets dans nos applications ?<br/>
                            Principalement pour limiter la complexit√© et am√©liorer la maitrise du code.
                        </aside>
                    </section>
                    <section data-background-image="img/separation-of-concerns.jpg" class="invert left">
                        <h1 class="highlight"><span>Pourquoi ?</span></h1>
                        <aside class="notes">
                            Lorsqu'on cr√©√© des applications complexes, on doit assembler des dizaines d'objets diff√©rents. Pour √™tre construit, chaque objet a ses contraintes qu'il faut comprendre pour savoir l'initialiser correctement.<br/>
                            <br/>
                            Aussi, lorsqu'on d√©finit des d√©pendances sur un objet gr√¢ce √† des interfaces, il faut aussi choisir d'injecter la bonne impl√©mentation utile au bon moment.<br/>
                            On peut avoir plusieurs impl√©mentations, utilis√©es √† plusieurs endroits de l'application. On commence √† sentir la complexit√© de cette construction d'objet.<br/>
                            <br/>
                            En fonction du contexte, de l'environnement, et potentiellement d'un tas d'autres crit√®res, vos applications sont initialis√©es et construites dynamiquement.<br/>
                            <br/>
                            Pour pouvoir mieux contr√¥ler ce qu'il se passe, le principe des conteneurs d'injection de d√©pendance s'est impos√©. On d√©clare de mani√®re plus ou moins automatique le processus de cr√©ation des objets. Ensuite quand on en a besoin, on demande au conteneur de nous cr√©er une instance en utilisant ces r√®gles.<br/>
                            <br/>
                            L'objet ainsi construit est viable et utilisable.<br/>
                            <br/>
                            On peut aussi facilement partager la m√™me instance d'objet sans passer par un singleton ou une r√©f√©rence statique ce qui n'est clairement pas une tr√®s bonne pratique aujourd'hui.
                        </aside>
                    </section>
                    <section data-background-image="img/separation-of-concerns.jpg" class="invert left">
                        <h1 class="highlight"><span>Comment ?</span></h1>
                        <aside class="notes">
                            Les impl√©mentations de conteneurs peuvent para√Ætre complexes et certaines le sont vraiment. Cependant, pour simplifier les choses, on peut imaginer qu'on cr√©√© un tableau de d√©finition d'objet.<br/>
                            <br/>
                            Il faut savoir que certaines impl√©mentations r√©elles comme le projet Pimple sont aussi basiques.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Une version basique</span></h1>
                        <pre style="font-size: 1.35rem" class="">
                            <code class="php">class Moteur
{
    public function __construct(string $name)
    {
        $this->name = $name;
    }
}</code>
                        </pre>
                        <aside class="notes">
                            Prenons d'abord deux objets : `Voiture` et `Moteur`. Notre objet Voiture a besoin d'un Moteur pour fonctionner. Jusque la tout le monde me suis j'imagine.<br/>
                            L'exemple est volontairement tr√®s limit√©, un moteur doit avoir uniquement un nom.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Une version basique</span></h1>
                        <pre style="font-size: 1.75rem" class="absolute top120">
                            <code class="php">class Voiture
{
    public function __construct()
    {
        $this->moteur = new Moteur('v8');
    }
}</code>
                        </pre>
                        <pre style="font-size: 1.75rem" class="fragment absolute fade-in top120">
                            <code class="php">class Voiture
{
    public function __construct(Moteur $moteur)
    {
        $this->moteur = $moteur;
    }
}</code>
                        </pre>
                        <aside class="notes">
                            Ensuite, je continue dans mon exemple. Mon objet `Voiture` a clairement besoin de `Moteur` pour s'initialiser correctement. Pour √ßa plusieurs solutions s'offrent √† nous. La premi√®re serait de cr√©er des `Moteur` directement quand on initialise la voiture. Le probl√®me c'est qu'avec cette m√©thode notre objet `Voiture` devient enti√®rement d√©pendant de l'impl√©mentation `Moteur` qu'il utilise. Il doit avoir conscience de comment construire une `Moteur`, comment la d√©clarer correctement.<br/>
                            <br>
                            Hors, de mani√®re symbolique, notre objet `Voiture` pourrait utiliser n'importe quel instance de `Moteur` sans que son comportement ne viennent √† changer.<br>
                            <br>
                            ‚ñ∂ Selon le D de SOLID, il faut que notre objet d√©pende des abstractions et pas des impl√©mentations. En r√©alit√©, notre voiture a besoin d'un objet r√©pondant √† l'API publique de `Moteur` et pas d'un moteur en particulier. On pr√©f√®rera donc utiliser la composition en modifiant notre objet `Voiture` pour qu'il d√©clare sa d√©pendance √† un `Moteur`.<br>
                            <br/>
                            On remarque aussi que, maintenant je n'ai qu'√† demander une voiture et l'objet moteur est construit √† la vol√©e dans ma d√©finition, je n'ai pas √† m'en pr√©occuper.<br/>
                            <br/>
                            Au final, un conteneur d'injection de d√©pendance est rarement plus complexe qu'un tableau de d√©finition en m√©moire. Cependant il y a pas mal d'outils compl√©mentaires pour d√©clarer ses d√©finitions.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Une version basique</span></h1>
                        <pre style="font-size: 1.75rem" class="">
                            <code class="php">$container = [
    'moteur' => static function (): Moteur {
        return new Moteur('standard');
    },
    'v8' => new Moteur('v8')
];</code>
                        </pre>
                        <aside class="notes">
                            On d√©clare ensuite dans un tableau, diff√©rentes fa√ßons de cr√©er un moteur, la seule contrainte est d'utiliser des noms diff√©rents. Bien sur en PHP, je ne peux pas voir dans un tableau deux valeurs diff√©rentes pour la m√™me cl√©.<br/>
                            <br/>
                            Ce qu'il est important de noter ici est la diff√©rence entre une methode de construction par exemple notre premi√®re fonction, et une r√©f√©rence √† une instance r√©elle en m√©moire. La premi√®re nous renverra toujours un nouvel objet √† chaque appel alors que la seconde nous transmet toujours le m√™me objet. Ainsi on peut partager un objet dans notre application.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Une version basique</span></h1>
                        <pre style="font-size: 1.5rem" class="">
                            <code class="php">$container['voiture'] = function () use ($container): Voiture {
    return new Voiture($container['moteur']);
};

$maVoiture = $container['voiture']();</code>
                        </pre>
                        <aside class="notes">
                            Je peux maintenant mettre √† jour mon "conteneur" qui est toujours un tableau de d√©finition, pour qu'il soit capable de construire plusieurs mod√®le de `Voiture` avec des moteurs diff√©rents.<br>
                            <br>
                            On note l'uitlisation de l'instruction `use` dans la d√©finition de la fonction qui me permet d'injecter la liste des d√©finitions connues pour l'utiliser.<br>
                            ‚ñ∂ Je sais maintenant comment initialiser une Voiture dans mon application. Il me suffit d'appeler la bonne fonction pour en g√©n√©rer une.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>Dans Symfony</span></h1>
                        <pre style="font-size: 1.25rem" class="">
                            <code class="yaml">#services.yaml
moteur:
    class: Moteur
    attributes:
        $name: 'standard'
v8:
    class: Moteur
    attributes:
        $name: 'v8'
voiture:
    class: Voiture
    attributes:
        $moteur: '@v8'</code>
                        </pre>
                        <aside class="notes">
                            Pour prendre l'exemple de Symfony, on peut remplir un fichier YAML. On peut aussi faire appel √† l'autowiring qui va detecter automatiquement les d√©pendances entre nos objets gr√¢ce √† l'API `Reflection` de PHP. Le code est donc analys√©, les d√©finitions en sont d√©duites et il ne reste plus qu'√† les utiliser. Gr√¢ce √† ces automatisations, il est de plus en plus facile d'utiliser ce conteneur dans vos projets.<br/>
                            <br/>
                            Cependant, l'automatisation ne doit pas cacher la complexit√© de la t√¢che. L'initialisation d'un conteneur peut √™tre tr√®s lourde et souvent un syst√®me de cache est utilis√© pour ne pas avoir √† le refaire √† chaque requ√™te. De toute fa√ßon, tant que le code ne bouge pas, les d√©finitions restent valides.
                        </aside>
                    </section>
                    <section data-background-image="img/why.jpg" class="left invert">
                        <h1 class="highlight"><span>Int√©r√™t ?</span></h1>
                        <p class="highlight">
                            <span class="fragment">D√©couplage, </span><span class="fragment">R√¥le, </span><span class="fragment">Architecture.</span>
                        </p>
                        <aside class="notes">
                            ‚ñ∂ Gr√¢ce √† ce pattern, il est possible de plus facilement d√©coupler les objets les uns des autres, les impl√©mentations des interfaces. Un objet d√©clare ses d√©pendances et le conteneur les r√©soud.
                            <br/>
                            Avant d'aller plus loin, qu'est-ce qu'on appelle une d√©pendance. On parle d'objet pour l'instant mais on peut g√©n√©raliser ce principe √† tout ce dont l'objet a besoin pour fonctionner: une configuration, un autre objet, un flag‚Ä¶
                            <br/>
                            ‚ñ∂ Le fait d'utiliser un objet pour construire les objets est aussi int√©ressant car il permet de se poser des questions. On est pas dans le mode, je construit tout petit √† petit en tombant des lignes de code. Ce conteneur va permettre de r√©fl√©chir √† l'architecture du code, aux int√©ractions entre les objets et c'est vraiment int√©ressant !
                            <br/>
                            Un exemple courant est l'utilisation plus g√©n√©rales d'interfaces. √Ä partir de la on d√©finit plusieurs impl√©mentations et on peut les assembler pour r√©pondre finement √† notre besoin. Chaque objet peut donc √™tre r√©duit √† son plus simple appareil, il faut une chose et le fait bien. Il d√©pend d'autres choses qui lui sont fournies pour fonctionner.
                            <br/>
                            ‚ñ∂ On se rapproche des grands principes comme SOLID ou KISS qui, m√™me s'ils ne sont pas des concepts √† suivre b√™tement aide √† avoir un code clair, testable et maintenable dans le temps.
                            <br/>
                            Bien sur ces principes sont applicables dans tout les cas lorsqu'on fait du d√©veloppement orient√© objet. Cependant le point central que nous offre le conteneur facilite les choses car toute l'application est initialis√©e √† partir des r√®gles qu'il contient. Seuls les objets utiles en fonction du contexte sont cr√©√©s et la r√©ponse finale est fournie √† l'utilisateur.
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section data-background-image="img/tools.jpg" class="left invert">
                        <h1 class="highlight"><span>Dans l'√©cosyst√®me PHP</span></h1>
                        <aside class="notes">
                            Maintenant que nous avons fait un petit topo sur ce qu'est un conteneur d'injection de d√©pendances, voyons ce qu'il existe sur le march√© pour utiliser ce pattern dans nos applications.<br/>
                            <br/>
                            En r√©alit√©, comme je le disais tout √† l'heure, il est d√©j√† tr√®s pr√©sent et m√™me central dans nos frameworks.
                        </aside>
                    </section>
                    <section data-background-image="img/frameworks.jpg" class="left invert">
                        <h1 class="highlight"><span>Dans les frameworks</span></h1>
                        <aside class="notes">
                            Dans la plupart des framework open source, on retrouve ce principe. Que ce soit Symfony, Laravel, Zend qui est d√©venu Laminas, CakePHP, Yii ou d'autres. Le principe d'injection de d√©pendance est omnipr√©sent et c'est tr√®s positif car on gagne en modularit√©.<br/>
                            Les impl√©mentations sont par contre tr√®s diff√©rentes. Voici quelques exemples utilisant Laravel et Laminas.
                        </aside>
                    </section>
                    <section class="left invert">
                        <pre style="font-size: 1.1rem" class="absolute">
                            <code class="php" data-line-numbers>/* Laravel */
class VoitureServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->bind('moteur', function (): Moteur {
            return new Moteur('standard');
        });
        $this->app->bind('v8', new Moteur('v8'));
        $this->app->bind('voiture', function (Application $app): Moteur {
            return new Voiture($app->make('v8'));
        });
    }
}
</code>
                        </pre>
                        <pre style="font-size: 1.1rem" class="fragment absolute fade-in">
                            <code class="php" data-line-numbers="5-11">/* Laravel */
class VoitureServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->bind('moteur', function (): Moteur {
            return new Moteur('standard');
        });
        $this->app->bind('v8', new Moteur('v8'));
        $this->app->bind('voiture', function (Application $app): Moteur {
            return new Voiture($app->make('v8'));
        });
    }
}
</code>
                        </pre>
                        <pre style="font-size: 1rem" class="fragment absolute fade-in">
                            <code class="php" data-line-numbers>/* Lamina service manager */
$serviceManager = new Laminas\ServiceManager\ServiceManager([
    'invokable' => [
        'v8' => new Moteur('v8')
    ],
    'factories' => [
        'moteur' => function(ContainerInterface $container, $requestedName) {
            return new Moteur('standard');
        },
        'voiture' => function(ContainerInterface $container, $requestedName) {
            return new Voiture($container->get('v8'));
        },
    ],
]);

$maVoiture = $serviceManager->get('voiture');
</code>
                        </pre>
                        <pre style="font-size: 1rem" class="fragment absolute fade-in">
                            <code class="php" data-line-numbers="4,7-12">/* Lamina service manager */
$serviceManager = new Laminas\ServiceManager\ServiceManager([
    'invokable' => [
        'v8' => new Moteur('v8')
    ],
    'factories' => [
        'moteur' => function(ContainerInterface $container, $requestedName) {
            return new Moteur('standard');
        },
        'voiture' => function(ContainerInterface $container, $requestedName) {
            return new Voiture($container->get('v8'));
        },
    ],
]);

$maVoiture = $serviceManager->get('voiture');
</code>
                        </pre>
                        <aside class="notes">
                            Ce premier exemple Laravel est √©crit sous forme de classe. En effet dans Laravel, le conteneur est configur√© dans un objet ServiceProvider. Dans ce framework, le conteneur est compl√®tement int√©gr√© √† l'objet Application. <br/>
                            ‚ñ∂ En dehors de ces sp√©cificit√©s, on retrouve notre d√©finition, tr√®s proche de ce qui √©tait d√©finit sous forme de tableau auparavant.<br/>
                            ‚ñ∂ Ensuite, on arrive sur le ServiceManager du projet Laminas, le remplacant du Zend Framework. Les noms des objets changent mais la logique reste la m√™me. On cr√©√© une liste de d√©finition d√©clar√©e qu'on peut lier ensemble, toujours dans l'exemple de la voiture.<br/>
                            ‚ñ∂ Le code sp√©cifique, utile √† notre application reste toujours relativement identique quelque soit le framework choisit. La seule chose un peu diff√©rente reste l'emplacement de la configuration du conteneur.<br/>
                            Pour Symfony nous en avons d√©j√† parl√© tout √† l'heure, par d√©faut la configuration se fait sous forme de fichier YAML.
                        </aside>
                    </section>
                    <section data-background-image="img/lego.jpg" class="left invert">
                        <h1 class="highlight"><span>Les solutions ind√©pendantes</span></h1>
                        <aside class="notes">
                            En plus des outils embarqu√©s dans nos frameworks pr√©f√©r√©s il existe pas mal de librairies open source aussi, toujours dans l'√©cosyst√®me PHP qui permettent de rendre ce service. Je compte Laminas comme un framework mais il ferait en r√©alit√© plut√¥t parti de cette section.<br/>
                            <br/>
                            Pimple, PHP-DI sont pour moi les deux plus connus. Le second, maintenu par Matthieu Napoli √† ma pr√©f√©rence. Non pas parce que Matthieu est derri√®re mais par ses possibilit√©s. Pimple est tr√®s proche de notre tableau et donc forc√©ment plus limit√©.<br/>
                            <br/>
                            Pour rester dans la m√™me lign√©e, voici deux exemples, toujours les m√™mes, utilisant Pimple et PHP-DI.
                        </aside>
                    </section>
                    <section class="left invert">
                        <pre style="font-size: 1.25rem" class="absolute">
                            <code class="php">$container = new Pimple\Container();

$container['moteur'] = function (): Moteur {
    return new Moteur('standard');
};
$container['v8'] = new Moteur('v8');
$container['voiture'] = $container->factory(
    function(Pimple\Container $c) {
        new Voiture($c['v8']);
    }
);

$maVoiture = $container['voiture'];
</code>
                        </pre>
                        <pre style="font-size: 1.25rem" class="fragment absolute">
                            <code class="php">$container = new DI\Container();

$container->set('moteur', function (): Moteur {
    return new Moteur('standard');
});
$container->set('v8', new Moteur('v8'));
$container->(
    'voiture',
    DI\factory(function (ContainerInterface $c): Voiture {
        new Voiture($c->get('v8'));
    }
);
$maVoiture = $container->make('voiture');
</code>
                        </pre>
                        <aside class="notes">
                            On voit que l'utilisation de ces outils est toujours relativement la m√™me. On d√©clare quelque part nos d√©finitions d'objets puis ont invoque les objets qui nous int√©ressent ensuite.<br/>
                            <br/>
                            Cependant, comme souvent lorsqu'on a se retrouve √† avoir plusieurs impl√©mentations il n'est pas facile de passer de l'une √† l'autre. Quel serait l'int√©r√™t ? C'est une bonne question et il est parfois difficile de trouver une bonne r√©ponse. Une application construite autour d'une suite d'outil se retrouve rarement √† devoir compl√®tement remplacer une brique par une autre.<br/>
                            <br/>
                            M√™me si √ßa arrive ce n'est pas la principale motivation derri√®re la normalisation et les recommandation autour de tel ou tel pattern.
                        </aside>
                    </section>
                    <section data-background-image="img/container.jpg" class="left invert">
                        <h1 class="highlight"><span>Normalisation et PSR11</span></h1>
                        <aside class="notes">
                            Le PHP-FIG, qui a √©crit les diff√©rentes PSR est un groupe de d√©veloppeurs et mainteneurs de logiciels Open Source. Ils ont choisit de s'allier pour trouver une direction commune √† diff√©rentes probl√©matiques de l'√©cosyst√®me PHP.<br/>
                            <br/>
                            Ils ont commenc√© avec les r√®gles d'√©criture de code et l'autoloading. Ensuite ils ont travaill√© sur pas mal de sujets diff√©rent, la gestion des logs, le cache, et aussi les conteneurs d'injection de d√©pendance.<br/>
                            <br/>
                            Leur objectif est clair, √™tre capable de d√©finir une abstraction sur laquelle s'appuyer pour construire des applications. En r√©alit√©, comme les objets que nous construisons, nos applications ont aussi des d√©pendances. Elles d√©pendent de tout un tas de choses mais surtout elles ont besoin d'un conteneur d'injection de d√©pendances pour fonctionner.<br/>
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>PSR11<small><small>Une interface pour les gouverner tous</small></small></span></h1>
                        <pre>
                            <code class="php">namespace Psr\Container;

interface ContainerInterface
{
    public function get($id);
    public function has($id);
}</code>
                        </pre>
                        <aside class="notes">
                            C'est la que la "normalisation" devient int√©ressante, ont peut d√©clarer avoir besoin d'un conteneur et ensuite libre √† l'utilisateur final de choisir celui qu'il pr√©f√®re. Encore mieux, je peux √©crire des librairies s'appuyant sur un conteneur et au final partager le m√™me que le reste de l'application parce que tous respectent la PSR-11.<br/>
                            <br/>
                            On peut dire, ok c'est une interface toute basique, deux m√©thodes‚Ä¶ Est-ce qu'il a vraiment fallu que tous les projets travaillent ensemble pour aboutir √† ce r√©sultat ? Pourtant, le fait que cette interface existe est une vraie r√©ussite pour l'ecosyst√®me. Elle repr√©sente le consensus autour de ce pattern. Ensuite libre √† vous de choisir de l'utiliser ou non, l'objectif final est l'interop√©rabilit√© entre les syst√®mes.
                            <br/>
                            Ces principes paraissent peut √™tre complexes mais si on voit une application comme un ensemble de briques, il faut qu'elles s'adaptent les unes aux autres. Si je peux limiter le nombre de briques utiles c'est l'id√©al car il y a moins de flou dans mon code et j'ai une vision plus claire de ce qu'il s'y passe.<br/>
                            <br/>
                            Forc√©ment quand une application est plus claire, elle est plus facile √† faire vivre dans le temps.
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section data-background-image="img/danger.jpg" class="left invert">
                        <h1 class="highlight"><span>Est-ce vraiment utile ?</span></h1>
                        <aside class="notes">
                            Forc√©ment je ne serais pas l√† √† vous en parler si je n'y croyais pas. Mais, si avec ces diff√©rents points je ne vous ai pas encore convaincu il y en a un que j'ai d√©j√† un peu √©voqu√© qui permet de faire briller les conteneurs d'injection de d√©pendances.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>IDD <small>Interface Driven Development ü§©</small></span></h1>
                        <pre style="font-size: 1.5rem" class="">
                            <code class="php">interface Moteur {
    public function demarrer(): bool;
}

interface Voiture {
    public function allerA(Destination $destination): bool;
}
                            </code>
                        </pre>
                        <aside class="notes">
                            Qu'est-ce que c'est ? Pour commencer on ne va pas √©crire du code mais plut√¥t d√©finir des comportements. Si je reviens sur mon exemple de base `Moteur`, `Voiture`, je peux cr√©er des interfaces pour ces deux concepts.<br/>
                            Qu'est ce qu'un moteur pour mon application, qu'elles sont ces capacit√©s ?<br/>
                            Ensuite m√™me question pour la voiture, quel est son int√©r√™t, comment l'utiliser ?<br/>
                            On affine ici, l'API publique de notre code tout en d√©clarant d√©j√† des d√©pendances autour des interfaces.<br/>
                            Ensuite je suis libre de cr√©er plusieurs impl√©mentations en respectant les contrats que d√©crivent mes interfaces. On se retrouve avec un peu plus de code, certe mais il est maintenant aussi facile de rajouter de nouveaux types de moteurs sans bousculer le code. Pour autant ces contrats servent aussi de garantie pour la compr√©hension du besoin m√©tier auquel on r√©pond. Si √† travers mes interfaces j'arrive √† mettre en lumi√®re une bonne compr√©hension des probl√®mes √† r√©soudre il y a de grandes chances pour r√©ussir √† les r√©soudre correctement.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>IDD <small>Interface Driven Development ü§©</small></span></h1>
                        <pre style="font-size: 1.5rem" class="">
                            <code class="php">class MoteurV8 implements Moteur
{
    public function demarrer() {
        $this->faireDuBruit();
    }
}</code>
                        </pre>
                        <aside class="notes">
                            On cr√©√© ici une impl√©mentation sp√©cifique du moteur v8. Cette classe va donc pouvoir d√©finir pr√©cisement les particularit√©s de ce moteur.<br/>
                            Il ne reste plus qu'√† d√©finir toutes les impl√©mentations utiles au projet, √©crire les d√©finitions dans le conteneur et le tour est jou√©. On obtient un code robuste (attention je n'ai pas dit facile √† √©crire !).
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight"><span>IDD <small>Interface Driven Development ü§©</small></span></h1>
                        <pre style="font-size: 1.5rem" class="">
                            <code class="php">$container['v8'] = new MoteurV8();
$container['voiture'] = function () use ($container): Voiture {
    return new Voiture($container['moteur']);
};

$maVoiture = $container['voiture']();</code>
                        </pre>
                        <aside class="notes">
                            Pour terminer sur cette partie, une fois ces interfaces et impl√©mentations √©crits il faut les connecter ensemble et c'est la que le conteneur vient jouer un r√¥le cl√© dans la communication entre les objets.<br/>
                            Finalement les d√©finitions ne changent pas. J'avais d√©j√† d√©finit une impl√©mentation de `Moteur` que j'injectai dans la voiture. La seule modification se situe dans ce qu'est un moteur v8. Maintenant on utilise l'impl√©mentation sp√©cifique plut√¥t que celle g√©n√©rique.<br/>
                            Cette histoire d'interface est toujours int√©ressante √† utiliser mais c'est comme toujours √ßa d√©pend du contexte. Certains vous diront que rien ne peux √™tre √©crit sans interface, je ne serais pas aussi ferm√©. Des contraintes on en a tous, le plus important est d'avoir une vision d'ensemble et plusieurs approches pour aboutir √† un r√©sultat, test√©, stable et qui r√©pond au besoin !<br/>
                            Ensuite on a toujours moyen de pinailler, de faire du refactoring, le code parfait n'existe pas et chaque d√©veloppeur voit les choses √† sa mani√®re.
                        </aside>
                    </section>
                </section>
                <section class="stack">
                    <section data-background-image="img/why.jpg" class="left invert">
                        <h1 class="highlight"><span>Pourquoi l'utiliser ?</span></h1>
                        <aside class="notes">
                            Maintenant qu'on a vu plusieurs fa√ßons d'utiliser ce pattern, revenons √† des choses plus r√©alistes. Comme je l'ai plusieurs fois, ces conteneurs sont au coeur de vos applications.<br/>
                            <br/>
                            La tendance actuelle est clairement √† l'automatisation de la configuration, √† cacher au maximum la complexit√© interne des outils pour les rendre plus accessibles. C'est discutable mais avoir conscience de comment √ßa fonctionne globalement est d√©j√† tr√®s important.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight" style="font-size: 3rem" ><span>Les capacit√© cach√©es de votre application ?</span></h1>
                        <pre style="font-size: 1.2rem" class="">
                            <code class="php">class CustomQueryPass implements CompilerPassInterface
{
    public function process(ContainerBuilder $container)
    {
        $container
            ->getDefinition(UploadExam::class)
            ->setArgument(
                '$files',
                $container->getDefinition('app.filesystem.tmp_dicom')
            );
    }
}</code>
                        </pre>
                        <aside class="notes">
                            Maintenant, vous allez pouvoir creuser un peu plus la documentation et les capacit√©s sp√©cifiques de vos projets.<br/>
                            <br/>
                            Symfony par exemple va permettre d'agir au moment de la compilation du conteneur pour adapter le comportement des objets. La partie √©merg√© est l'utilisation des `tag` dans vos fichiers `yaml`. Lors de la compilation, Symfony les utilise pour les correctement les objets ensemble selon vos pr√©f√©rences.<br/>
                            Ensuite vous pouvez aller plus loin et utiliser les `CompilerPass` pour agir sur certains points directement.<br/>
                            Pour prendre un exemple assez courant, la manipulation de fichiers. J'ai l'habitude d'utiliser la librairie Flysystem qui propose une abstraction int√©ressante pour lire ou √©crire des fichiers dans un syst√®me de fichier. Ce syst√®me peut √™tre un dossier local, un bucket Amazon S3, un disque FTP ou autre, l'impl√©mentation reste la m√™me gr√¢ce aux interfaces.<br/>

                            On peut choisir au moment de la compilation du conteneur d'injecter tel ou tel impl√©mentation de syst√®me de fichier dans notre objet. On voit ici qu'on r√©cup√®re la d√©finition d'un classe `UploadExam` et qu'on va surcharger le param√®tre `$files` du constructeur pour utiliser une autre d√©finition `app.filesystem.tmp_dicom`.<br/>
                            Une fois ce genre d'objet √©crit, il suffit de l'enregistrer dans le Kernel de votre application pour qu'il soit utilis√©.<br/>
                            C'est clairement un exemple tr√®s naif, je vous invite √† regarder dans les diff√©rents composants et bundle Symfony qui utilise beaucoup des `CompilerPass` pour g√©rer les configurations √©crites en YAML.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight" style="font-size: 3rem"><span>Derni√®res nouveaut√©s Symfony ?</span></h1>
                        <img src="img/tweet.png" />
                        <aside class="notes">
                            Pour continuer sur Symfony, j'ai r√©cemment vu un Tweet qui parlent d'utiliser les attributs PHP8 pour d√©clarer le type d'argument attendu dans une action de controller.<br/>
                            <br/>
                            Ici on d√©clare un attribut type `CurrentUser` qui va permettre d'injecter l'utilisateur courant connect√© directement dans la variable `$user`.
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight" style="font-size: 3rem"><span>Derni√®res nouveaut√©s Symfony ?</span></h1>
                        <pre style="font-size: 1.2rem" class="">
                            <code class="php">use App\Entity\MyUser;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\Security\Http\Attribute\CurrentUser;

class SomeController extends AbstractController
{
    public function index(#[CurrentUser] MyUser $user)
    {
        // ...
    }
}</code>
                        </pre>
                        <aside class="notes">
                            Je suis assez √©tonn√© de voir ce genre d'ajout dans le Framework‚Ä¶ Ce sont des raccourcis pour des choses d√©j√† facilement r√©alisable en utilisant le conteneur d'injection de d√©pendances.<br/>
                            <br/>
                            Bien sur, en utilisant ce type de syntaxe, on laisse enti√®rement Symfony g√©rer le mapping entre notre variable `$user` on arrive donc plus vite au r√©sultat.<br/>
                            <br/>
                            Sauf que, sans l'impl√©mentation dynamique de cet attribut dans Symfony, mon code n'est pas testable. Si ce controleur d√©pend de l'utilisateur courant, je pourrais tout √† fait cr√©er un service qui permet de r√©cup√©rer l'utilisateur connect√© et inject√© ce service comme d√©pendance de mon contr√¥leur. Un peu plus de code mais une meilleure ma√Ætrise selon moi de ce qu'il se passe dans votre application.<br/>
                            <br/>
                            J'ai toujours un peu peur, des outils trop magiques ou qui font trop de choses pour moi. Non pas que je n'aime pas √©crire moins de code pour obtenir le m√™me r√©sultat mais si demain l'impl√©mentation fournie dans le framework ne me va pas, il faut toujours savoir comment la contourner pour adapter le code.<br/>
                        </aside>
                    </section>
                    <section class="left invert">
                        <h1 class="highlight" style="font-size: 3rem"><span>Convention ou maitrise des outils ?</span></h1>
                        <p class="highlight"><span class="fragment">Facilit√©, </span><span class="fragment">Documentation.</span></p>
                        </pre>
                        <aside class="notes">
                            Est-ce que vous voulez que votre code respectent scrupuleusement des conventions pour obtenir un r√©sultat avec peu de code ?<br/>
                            <br/>
                            ‚ñ∂ La plupart des d√©veloppeurs que je connais r√©pondront oui, moi y compris. Le soucis est, comme d'habitude de ne pas s'enfermer dans un framework avec ses conventions. Quand on utilise une convention il faut savoir qu'on le fait et surtout il faut avoir une vision g√©n√©rale de ce qu'il se passe derri√®re.<br/>
                            <br/>
                            Si on sait que c'est un raccourci, qu'on sait comment faire autrement, alors bien sur on ne se prive pas de l'utiliser ! Comme je le dis souvent, les d√©veloppeurs sont feignant et ont besoin de l'√™tre. Ils doivent chercher √† √©crire le moins de code possible pour r√©soudre les probl√®mes qu'on leur soumet.<br/>
                            <br/>
                            ‚ñ∂ Cependant un d√©veloppeur se doit aussi de bien connaitre ses outils parce que s'il y a un probl√®me, et il y en aura toujours, il doit pouvoir corriger le bug rapidement plut√¥t que se perdre dans de la documentation ou StackOverflow.<br/>
                            <br/>
                            Pour finir, je ne dis pas que la communaut√© Symfony a mal fait d'int√©grer ce type d'attribut. Gardons un oeil critique, tout les outils ont leur force et leur faiblesse. Nous sommes des d√©veloppeurs PHP, pas Symfony ou Laravel. Essayez de connaitre les patterns, de r√©fl√©chir √† l'architecture de votre code et vous verrez que de plus en plus vous trouverez des solutions √©l√©gantes et fiables aux probl√®mes complexes que ce soit avec des conventions ou votre propre code !
                            <br/>
                        </aside>
                    </section>
                </section>
<!--#########################################################################-->
                <section class="invert" data-background-image="img/thank-you.jpg">
                    <aside class="notes">
                        Merci de votre attention.
                    </aside>
                </section>
            </div>
        </div>

        <script src="../assets/reveal.js/js/reveal.js"></script>
        <script src="../assets/javascripts/mermaid.min.js"></script>

        <script>
            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: false,
                progress: true,
                history: true,
                center: true,
                pdfSeparateFragments: false,

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: '../assets/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: '../assets/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../assets/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: '../assets/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: '../assets/reveal.js/plugin/zoom-js/zoom.js', async: true },
                    { src: '../assets/reveal.js/plugin/notes/notes.js', async: true }
                ]
            });

            mermaid.initialize({startOnLoad:true});
        </script>
    </body>
</html>
